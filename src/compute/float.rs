//! Computes the position of floats in a block formatting context
//!
//! Here are the precise rules that govern the behavior of floats:
//!
//! 1. The left outer edge of a left-floating box may not be to the left of the left edge of its containing block. An analogous rule
//!    holds for right-floating elements.
//! 2. If the current box is left-floating, and there are any left-floating boxes generated by elements earlier in the source document,
//!    then for each such earlier box, either the left outer edge of the current box must be to the right of the right outer edge of the earlier box,
//!    or its top must be lower than the bottom of the earlier box. Analogous rules hold for right-floating boxes.
//! 3. The right outer edge of a left-floating box may not be to the right of the left outer edge of any right-floating box that is next to it.
//!    Analogous rules hold for right-floating elements.
//! 4. A floating box's outer top may not be higher than the top of its containing block. When the float occurs between two collapsing margins,
//!    the float is positioned as if it had an otherwise empty anonymous block parent taking part in the flow. The position of such a parent is defined
//!    by the rules in the section on margin collapsing.
//! 5. The outer top of a floating box may not be higher than the outer top of any block or floated box generated by an element earlier in the source document.
//! 6. The outer top of an element's floating box may not be higher than the top of any line-box containing a box generated by
//!    an element earlier in the source document.
//! 7. A left-floating box that has another left-floating box to its left may not have its right outer edge to the right of its containing block's
//!    right edge. (Loosely: a left float may not stick out at the right edge, unless it is already as far to the left as possible.) An analogous rule
//!    holds for right-floating elements.
//! 8. A floating box must be placed as high as possible.
//! 9. A left-floating box must be put as far to the left as possible, a right-floating box as far to the right as possible. A higher position is
//!    preferred over one that is further to the left/right.
//!
//! But in CSS 2.2, if, within the block formatting context, there is an in-flow negative vertical margin such that the float's position is above the position it would be at were all such negative margins set to zero, the position of the float is undefined.
//!
//! <https://www.w3.org/TR/CSS22/visuren.html#floats>

use crate::{AvailableSpace, Point};

/// A context for placing floated boxes
#[derive(Debug, Clone)]
pub struct FloatContext {
    available_space: AvailableSpace,
    /// A list of left-floated boxes within the context
    left_floats: Vec<PlacedFloatedBox>,
    /// A list of right-floated boxes within the context
    right_floats: Vec<PlacedFloatedBox>,
    /// A list of non-overlapping horizontal segments within the context.
    /// Each segment has the same available width for it's entire height.
    segments: Vec<Segment>,
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum FloatDirection {
    Left,
    Right,
}

/// A floated box to place within the context
#[derive(Debug, Clone, Default)]
pub struct FloatedBox {
    /// A user defined ID for the box
    id: u64,
    width: f32,
    height: f32,
}

/// A floated box
#[derive(Debug, Clone, Default)]
struct PlacedFloatedBox {
    /// A user defined ID for the box
    id: u64,
    width: f32,
    height: f32,
    /// Distance from the edge of the container that the box is floated towards
    /// (distance from the left for left floats, from the right for right floats)
    x_inset: f32,
    y: f32,
}

impl PlacedFloatedBox {
    const DEFAULT: Self = Self { id: 0, width: 0.0, height: 0.0, x_inset: 0.0, y: 0.0 };
}

#[derive(Debug, Clone)]
struct Segment {
    y_start: f32,
    y_end: f32,
    inset_left: f32,
    inset_right: f32,
}

impl FloatContext {
    /// Create a new empty `FloatContext`
    pub fn new(available_space: AvailableSpace) -> Self {
        Self { available_space, left_floats: Vec::new(), right_floats: Vec::new(), segments: Vec::new() }
    }

    /// Position a floated box with the context
    pub fn place_floated_box(&mut self, floated_box: FloatedBox, float_direction: FloatDirection) -> Point<f32> {
        let last_float = self.get_float_list(float_direction).last().unwrap_or(&PlacedFloatedBox::DEFAULT);

        let (x_inset, y): (f32, f32) = match self.available_space {
            AvailableSpace::MinContent => {
                let x_inset = 0.0;
                let y = last_float.y + last_float.height;
                (x_inset, y)
            }
            AvailableSpace::MaxContent => {
                let x_inset = last_float.x_inset + last_float.width;
                let y = last_float.y;
                (x_inset, y)
            }
            AvailableSpace::Definite(available_width) => {
                let line_available_width = available_width - last_float.x_inset - last_float.width;

                if line_available_width < floated_box.width {
                    let x_inset = 0.0;
                    let y = last_float.y + last_float.height;
                    (x_inset, y)
                } else {
                    let x_inset = last_float.x_inset + last_float.width;
                    let y = last_float.y;
                    (x_inset, y)
                }
            }
        };

        let placed_floated_box =
            PlacedFloatedBox { id: floated_box.id, width: floated_box.width, height: floated_box.height, x_inset, y };

        match float_direction {
            FloatDirection::Left => self.left_floats.push(placed_floated_box),
            FloatDirection::Right => self.right_floats.push(placed_floated_box),
        }

        // Return the (x, y) coordinates of the positioned box
        return match self.available_space {
            // Position won't actually be used if we're layouting under a min-content
            // or max-content constraint, so just return (0, 0)
            AvailableSpace::MinContent | AvailableSpace::MaxContent => Point::ZERO,
            AvailableSpace::Definite(width) => match float_direction {
                FloatDirection::Left => Point { x: x_inset, y },
                FloatDirection::Right => Point { x: width - x_inset, y },
            },
        };
    }

    fn get_float_list(&self, float_direction: FloatDirection) -> &[PlacedFloatedBox] {
        match float_direction {
            FloatDirection::Left => &self.left_floats,
            FloatDirection::Right => &self.right_floats,
        }
    }
}
