//! Computes the position of floats in a block formatting context
//!
//! Here are the precise rules that govern the behavior of floats:
//!
//! 1. The left outer edge of a left-floating box may not be to the left of the left edge of its containing block. An analogous rule
//!    holds for right-floating elements.
//! 2. If the current box is left-floating, and there are any left-floating boxes generated by elements earlier in the source document,
//!    then for each such earlier box, either the left outer edge of the current box must be to the right of the right outer edge of the earlier box,
//!    or its top must be lower than the bottom of the earlier box. Analogous rules hold for right-floating boxes.
//! 3. The right outer edge of a left-floating box may not be to the right of the left outer edge of any right-floating box that is next to it.
//!    Analogous rules hold for right-floating elements.
//! 4. A floating box's outer top may not be higher than the top of its containing block. When the float occurs between two collapsing margins,
//!    the float is positioned as if it had an otherwise empty anonymous block parent taking part in the flow. The position of such a parent is defined
//!    by the rules in the section on margin collapsing.
//! 5. The outer top of a floating box may not be higher than the outer top of any block or floated box generated by an element earlier in the source document.
//! 6. The outer top of an element's floating box may not be higher than the top of any line-box containing a box generated by
//!    an element earlier in the source document.
//! 7. A left-floating box that has another left-floating box to its left may not have its right outer edge to the right of its containing block's
//!    right edge. (Loosely: a left float may not stick out at the right edge, unless it is already as far to the left as possible.) An analogous rule
//!    holds for right-floating elements.
//! 8. A floating box must be placed as high as possible.
//! 9. A left-floating box must be put as far to the left as possible, a right-floating box as far to the right as possible. A higher position is
//!    preferred over one that is further to the left/right.
//!
//! But in CSS 2.2, if, within the block formatting context, there is an in-flow negative vertical margin such that the float's position is above the position it would be at were all such negative margins set to zero, the position of the float is undefined.
//!
//! <https://www.w3.org/TR/CSS22/visuren.html#floats>

use core::ops::{Range, RangeInclusive};

use crate::{AvailableSpace, Clear, Point, Size};

/// A context for placing floated boxes
#[derive(Debug, Clone)]
pub struct FloatContext {
    available_space: AvailableSpace,
    /// A list of left-floated boxes within the context
    left_floats: Vec<PlacedFloatedBox>,
    /// A list of right-floated boxes within the context
    right_floats: Vec<PlacedFloatedBox>,
    /// A list of non-overlapping horizontal segments within the context.
    /// Each segment has the same available width for it's entire height.
    placer: FloatPlacer,
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum FloatDirection {
    Left = 0,
    Right = 1,
}

/// A floated box to place within the context
#[derive(Debug, Clone, Copy, Default)]
pub struct FloatedBox {
    /// A user defined ID for the box
    // pub(crate) id: u64,
    pub(crate) width: f32,
    pub(crate) height: f32,
}

/// A floated box
#[derive(Debug, Clone, Default)]
struct PlacedFloatedBox {
    /// A user defined ID for the box
    // id: u64,
    width: f32,
    height: f32,
    /// Distance from the edge of the container that the box is floated towards
    /// (distance from the left for left floats, from the right for right floats)
    x_inset: f32,
    y: f32,
}

impl PlacedFloatedBox {
    const DEFAULT: Self = Self { /*id: 0, */ width: 0.0, height: 0.0, x_inset: 0.0, y: 0.0 };
}

impl FloatContext {
    /// Create a new empty `FloatContext`
    pub fn new(available_space: AvailableSpace) -> Self {
        Self {
            available_space,
            left_floats: Vec::new(),
            right_floats: Vec::new(),
            placer: FloatPlacer::new(available_space),
        }
    }

    /// Create a new empty `FloatContext`
    pub fn set_width(&mut self, available_space: AvailableSpace) {
        self.available_space = available_space;
    }

    /// Position a floated box with the context
    pub fn place_floated_box(
        &mut self,
        size: Size<f32>,
        min_y: f32,
        containing_block_insets: [f32; 2],
        direction: FloatDirection,
        clear: Clear,
    ) -> Point<f32> {
        // let last_float = self.get_float_list(direction).last().unwrap_or(&PlacedFloatedBox::DEFAULT);

        // let do_wrap = match self.available_space {
        //     AvailableSpace::MinContent => true,
        //     AvailableSpace::MaxContent => false,
        //     AvailableSpace::Definite(available_width) => {
        //         let line_available_width = available_width - last_float.x_inset - last_float.width;
        //         line_available_width < size.width
        //     }
        // };

        // let (x_inset, y) = match do_wrap {
        //     true => {
        //         let x_inset = 0.0;
        //         let y = last_float.y + last_float.height;
        //         (x_inset, y)
        //     }
        //     false => {
        //         let x_inset = last_float.x_inset + last_float.width;
        //         let y = last_float.y;
        //         (x_inset, y)
        //     }
        // };

        // Return the (x, y) coordinates of the positioned box
        match self.available_space {
            // Position won't actually be used if we're layouting under a min-content
            // or max-content constraint, so just return (0, 0)
            AvailableSpace::MinContent | AvailableSpace::MaxContent => Point::ZERO,
            AvailableSpace::Definite(container_width) => {
                let placed_floated_box =
                    self.placer.place_float(min_y, size, containing_block_insets, direction, clear);
                let x_inset = placed_floated_box.x_inset;
                let y = placed_floated_box.y;
                match direction {
                    FloatDirection::Left => {
                        self.left_floats.push(placed_floated_box);
                        Point { x: x_inset, y }
                    }
                    FloatDirection::Right => {
                        self.right_floats.push(placed_floated_box);
                        Point { x: container_width - x_inset - size.width, y }
                    }
                }
            }
        }
    }

    pub(crate) fn content_width(&self) -> f32 {
        match self.available_space {
            AvailableSpace::Definite(width) => width,
            AvailableSpace::MinContent => {
                let left_max =
                    self.left_floats.iter().map(|float| float.x_inset).max_by(|a, b| a.total_cmp(b)).unwrap_or(0.0);
                let right_max =
                    self.right_floats.iter().map(|float| float.x_inset).max_by(|a, b| a.total_cmp(b)).unwrap_or(0.0);
                left_max.max(right_max)
            }
            AvailableSpace::MaxContent => {
                let left_max = self.left_floats.last().map(|float| float.x_inset).unwrap_or(0.0);
                let right_max = self.right_floats.last().map(|float| float.x_inset).unwrap_or(0.0);
                left_max + right_max
            }
        }
    }

    pub(crate) fn content_height(&self) -> f32 {
        self.placer.segments.last().map(|seg| seg.y.end).unwrap_or(0.0)
    }

    fn get_float_list(&self, float_direction: FloatDirection) -> &[PlacedFloatedBox] {
        match float_direction {
            FloatDirection::Left => &self.left_floats,
            FloatDirection::Right => &self.right_floats,
        }
    }
}

#[derive(Debug, Clone)]
struct Segment {
    y: Range<f32>,
    // Left inset in slot 0. Right inset in slot 1.
    insets: [f32; 2],
    // y_end: f32,
    // left_inset: f32,
    // right_inset: f32,
}

impl Segment {
    fn fits_float_width(&self, floated_box: Size<f32>, direction: FloatDirection, bfc_width: f32) -> bool {
        let slot = direction as usize;
        self.insets[slot] == 0.0 || (bfc_width - floated_box.width - self.inset_sum()) > 0.0
    }

    #[inline(always)]
    fn inset_sum(&self) -> f32 {
        self.insets[0] + self.insets[1]
    }
}

#[derive(Debug, Clone, Default)]
struct FloatPlacer {
    // Calling into this
    bfc_width: f32,

    segments: Vec<Segment>,
    // Left hwm in slot 0. Right hwm in slot 1.
    // high_water_marks: [usize; 2],
    /// A closed-open range indicating which segment the last placed float
    /// was placed(on each side).
    last_placed_floats: [Range<usize>; 2],
    // left_float_high_water_mark: usize,
    // right_float_high_water_mark: usize,
}

#[derive(Debug, Clone)]
struct FloatFitter {
    bfc_width: f32,
    available_height: f64,
    insets: [f32; 2],
}

impl FloatFitter {
    fn new(bfc_width: f32, available_height: f32, insets: [f32; 2]) -> Self {
        Self { bfc_width, available_height: available_height as f64, insets }
    }

    // Horizontal fitting

    fn union_insets(&mut self, insets: [f32; 2]) {
        self.insets[0] = self.insets[0].max(insets[0]);
        self.insets[1] = self.insets[1].max(insets[1]);
    }

    fn fits_horiontally(&self, width: f32) -> bool {
        self.insets == [0.0, 0.0] || self.bfc_width - self.insets[0] - self.insets[1] - width >= 0.0
    }

    // Vertical fitting

    fn add_height(&mut self, height: f32) {
        self.available_height += height as f64;
    }

    fn fits_vertically(&mut self, height: f32) -> bool {
        self.available_height >= height as f64
    }
}

impl FloatPlacer {
    fn new(available_space: AvailableSpace) -> Self {
        Self {
            bfc_width: match available_space {
                AvailableSpace::Definite(width) => width,
                AvailableSpace::MinContent => 0.0,
                AvailableSpace::MaxContent => f32::INFINITY,
            },
            segments: Vec::new(),
            last_placed_floats: [0..0, 0..0], // high_water_marks: [0, 0],
        }
    }

    fn subdivide_segment(&mut self, idx: usize, divide_at_y: f32) {
        let old_segment = &mut self.segments[idx];
        let new_segment = Segment { insets: old_segment.insets, y: divide_at_y..old_segment.y.end };
        if !old_segment.y.contains(&divide_at_y) || old_segment.y.start == divide_at_y {
            dbg!(&old_segment);
            dbg!(divide_at_y);
            assert!(old_segment.y.contains(&divide_at_y) && old_segment.y.start != divide_at_y);
        }
        old_segment.y.end = divide_at_y;

        self.segments.splice((idx + 1)..(idx + 1), core::iter::once(new_segment));
    }

    fn update_last_placed_float(&mut self, direction: FloatDirection, placement: Range<usize>) {
        let slot = direction as usize;
        self.last_placed_floats[slot].start = self.last_placed_floats[slot].start.max(placement.start);
        self.last_placed_floats[slot].end = self.last_placed_floats[slot].end.max(placement.end);
    }

    fn place_float(
        &mut self,
        min_y: f32,
        floated_box: Size<f32>,
        containing_block_insets: [f32; 2],
        direction: FloatDirection,
        clear: Clear,
    ) -> PlacedFloatedBox {
        let slot = direction as usize;

        // Ensure that float:
        //    - Starts at or after the last placed float that was floated in the same direction as it
        //    - Respects "clear"
        let hwm = match clear {
            Clear::Left => {
                let float_dir_start = self.last_placed_floats[slot].start;
                let left_end = self.last_placed_floats[0].end;
                float_dir_start.max(left_end)
            }
            Clear::Right => {
                let float_dir_start = self.last_placed_floats[slot].start;
                let right_end = self.last_placed_floats[1].end;
                float_dir_start.max(right_end)
            }
            Clear::Both => {
                let left_end = self.last_placed_floats[0].end;
                let right_end = self.last_placed_floats[1].end;
                left_end.max(right_end)
            }
            Clear::None => {
                // float_dir_start
                self.last_placed_floats[slot].start
            }
        };

        // Ensure that float is placed in a segment at or below "min_y"
        // (ensuring that it is placed at or below min_y within it's segment happens below)
        let start_idx = self.segments[hwm..].iter().position(|segment| segment.y.end > min_y).map(|idx| idx + hwm);

        let mut start_idx = start_idx.unwrap_or(self.segments.len());
        let mut start_y = min_y;
        let mut end_idx = start_idx;
        // let mut end_y = min_y;

        // Loop over remaining segments, trying to place the float in a position
        // that has space to accomodate it.
        let (start, mut end, placed_inset) = 'outer: loop {
            // Start segment does not exist:
            //
            // This means no existing segment can accomodate the float so we must create a new
            // segment below all existing segments. A new segment will always have space for
            // the float, so we can exit the loop at this point.
            let Some(start_segment) = self.segments.get(start_idx) else {
                break (None, None, 0.0);
            };

            // Candidate start segment doesn't have (horizontal) space for the float:
            // => retry with the next segment
            if !start_segment.fits_float_width(floated_box, direction, self.bfc_width) {
                start_idx += 1;
                end_idx = end_idx.max(start_idx);
                continue;
            }

            start_y = start_y.max(start_segment.y.start);
            let available_height = start_segment.y.end - start_y;
            let mut fitter = FloatFitter::new(self.bfc_width, available_height, containing_block_insets);
            fitter.union_insets(start_segment.insets);

            // Pinning the start segment, loop over segments starting with the start segment
            // to find the end segment:
            //   - The selected segment range must have enough height to contain the float
            //   - All of the segments in the range must have enough horizontal width to contain the float
            //     TODO: must ensure that width is in the correct place.
            loop {
                // End segment does not exist:
                //
                // This means no existing segment can accomodate the float so we must create a new
                // segment below all existing segments
                let Some(end_segment) = self.segments.get(end_idx) else {
                    let inset = fitter.insets[slot];
                    break 'outer (Some(start_idx), None, inset);
                };

                // Check horizontal fit
                //
                // If it does not fit horizontally then it will never fit in this position, so
                // continue the outer loop to find and check a new position
                fitter.union_insets(end_segment.insets);
                if !fitter.fits_horiontally(floated_box.width) {
                    start_idx += 1;
                    end_idx = end_idx.max(start_idx);
                    continue 'outer;
                }

                // Check vertical fit
                //
                // If it does not (yet) fit vertically then continue the inner loop to add another
                // segment to the range of segments we are placing the float in
                if end_idx != start_idx {
                    fitter.add_height(end_segment.y.end - end_segment.y.start);
                }
                if !fitter.fits_vertically(floated_box.height) {
                    end_idx += 1;
                    continue;
                }

                let inset = fitter.insets[slot];
                break 'outer (Some(start_idx), Some(end_idx), inset);
            }
        };

        // Short-circuit for zero-sized boxes
        if floated_box.width == 0.0 || floated_box.height == 0.0 {
            // TODO: need to update last_placed_float?

            return PlacedFloatedBox {
                width: floated_box.width,
                height: floated_box.height,
                y: start_y,
                x_inset: placed_inset,
            };
        }

        // Handle case where floated box is placed after all existing segments
        if start.is_none() {
            let last_y_end = self.segments.last().map(|seg| seg.y.end).unwrap_or(0.0);
            if start_y > last_y_end {
                self.segments.push(Segment { y: last_y_end..start_y, insets: [0.0, 0.0] });
            }

            let start_y = last_y_end.max(start_y);

            let mut insets = containing_block_insets;
            insets[slot] += floated_box.width;
            self.segments.push(Segment { y: start_y..(start_y + floated_box.height), insets });

            // Update last_placed_float
            let start_idx = self.segments.len() - 1;
            let end_idx = start_idx + 1;
            self.update_last_placed_float(direction, start_idx..end_idx);

            return PlacedFloatedBox {
                width: floated_box.width,
                height: floated_box.height,
                y: start_y,
                x_inset: containing_block_insets[slot],
            };
        }

        // Else unwrap the index of the segment that the start of the floating box is placed in
        let mut start_idx = start.unwrap();

        // If the floated box doesn't start at the exact same y-offset as the segment it starts in, then
        // subdivide that segment into two segments at the y-offset that the floated box starts at, and increment
        // `start_idx` so that the floating box is placed in the second of the two segments.
        if start_y != self.segments[start_idx].y.start {
            self.subdivide_segment(start_idx, start_y);
            start_idx += 1;
            if let Some(end_idx) = end.as_mut() {
                *end_idx += 1;
            }
        }

        let end_idx = match end {
            None => {
                let last_y_end = self.segments.last().map(|seg| seg.y.end).unwrap_or(0.0);
                if min_y > last_y_end {
                    self.segments.push(Segment { y: last_y_end..min_y, insets: [0.0, 0.0] });
                }
                self.segments.len() - 1
            }
            Some(end_idx) => {
                let end_y = start_y + floated_box.height;
                if end_y != self.segments[end_idx].y.end {
                    self.subdivide_segment(end_idx, end_y);
                }

                end_idx
            }
        };

        // Update inset for the range of segments that the float is placed in
        let placed_inset_plus_width = placed_inset + floated_box.width;
        for segment in &mut self.segments[start_idx..=end_idx] {
            segment.insets[slot] = placed_inset_plus_width;
        }

        // Update last_placed_float
        self.update_last_placed_float(direction, start_idx..(end_idx + 1));

        PlacedFloatedBox { width: floated_box.width, height: floated_box.height, y: start_y, x_inset: placed_inset }
    }

    fn place_non_floated_content(&mut self, min_y: f32, height: f32) -> (Point<f32>, Size<f32>) {
        todo!()
    }
}
